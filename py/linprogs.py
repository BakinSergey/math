# Есть поставщики товара со складами в разных трёх городах,
# причём объёмы однородной продукции на этих складах соответственно равны a1, a2, a3.
# Есть и потребители в других трёх городах которым нужно привести товар от поставщиков
# в объёмах b1, b2, b3 соответственно. Известны также стоимости доставки с1÷с9 товаров
# от поставщиков к потребителям, согласно таблице.

#           b1=74    b2=40     b3=36
# a1=20     c1=7     c2=3      c=6
# a2=45     c3=4     c4=8      c=2
# a3=30     c6=1     c7=5      c=9

# Если обозначить через x1…xn количество перевозимого груза, тогда функцией цели будет общая стоимость перевозки:
#
# F(x)=c1*x1+c2*x2+c3*x3+c4*x4+c5*x5+c6*x6+c7*x7+c8*x8+c9*x9.
#
# Условия, которые записываться. в виде неравенств:
#
# x1+x2+x3<=20 – больше чем есть у поставщика не возьмёшь
# x4+x5+x6<=45
# x7+x8+x9<=30
#
# Условия, которые записываться. в виде равенств:
#
# x1+x4+x7=b1 – сколько надо столько и привезём
# x2+x5+x8=b2
# x3+x6+x9=b3
#
# Тут дополнительно нужны условия не отрицательности переменных x поскольку они по смыслу не отрицательны
# и ищется минимум F(x). Эти неравенства не приводим.

import numpy as np
from scipy.optimize import linprog

b_ub = [74, 40, 36]
b_eq = [20, 45, 30]
A = np.array([[7, 3, 6], [4, 8, 2], [1, 5, 9]])
m, n = A.shape
c = list(np.reshape(A, n * m))  # Преобразование матрицы A в список c.
A_ub = np.zeros([m, m * n])
for i in np.arange(0, m, 1):  # Заполнение матрицы условий –неравенств.
    for j in np.arange(0, n * m, 1):
        if i * n <= j <= n + i * n - 1:
            A_ub[i, j] = 1
A_eq = np.zeros([m, m * n])
for i in np.arange(0, m, 1):  # Заполнение матрицы условий –равенств.
    k = 0
    for j in np.arange(0, n * m, 1):
        if j == k * n + i:
            A_eq[i, j] = 1
            k = k + 1

print(linprog(c, A_ub, b_ub, A_eq, b_eq))
